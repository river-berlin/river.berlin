<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="../../favicon.svg" />
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Reenie+Beanie&display=swap" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css2?family=Sofia+Sans:wght@400;700&display=swap" rel="stylesheet">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>River's blog</title>
		
		<link href="../../_app/immutable/assets/0.DvKdRuI4.css" rel="stylesheet">
		<link rel="modulepreload" href="../../_app/immutable/entry/start.ZZYciD6m.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/entry.BqmF0jbh.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/runtime.ZCwqNjaL.js">
		<link rel="modulepreload" href="../../_app/immutable/entry/app.CEGcWpwQ.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/render.Cp3DLeft.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/svelte-head.gad1Cy0X.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/disclose-version.I9ZBIlgW.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/if._s0Q-GvM.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/props.BOsS9Mwd.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/store.Do8w5Rs3.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/3.CcX-R9Fi.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/0.Cu_7sCj3.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/legacy.CusTTcTb.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/slot.BCWeK855.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/attributes.D0Rg-eRJ.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/lifecycle.C3edSOH9.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/stores.C3PEO250.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/5.DAxNCkMl.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/html.DMQsLNmD.js"><!--[--><meta name="twitter:title" content="River's Blog: Book takeaways - Why I feel Svelte is better than React (it's state management)"> <meta property="og:title" content="River's Blog: Book takeaways - Why I feel Svelte is better than React (it's state management)"> <meta property="og:url" content="https://river.berlin/blog/blog-5/"> <meta property="og:type" content="article"> <meta property="article:publisher" content="https://river.berlin"> <meta property="og:image" content="https://river.berlin/opengraph/blog/5.png"> <meta name="twitter:image" content="https://river.berlin/opengraph/blog/5.png"> <meta property="og:image:secure_url" content="https://river.berlin/opengraph/blog/5.png"> <meta property="og:description" content="Why I feel Svelte is better than React (it's state management)"> <meta property="og:image:width" content="1000"> <meta property="og:image:height" content="500"> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:site" content="https://river.berlin"> <meta name="twitter:description" content="Why I feel Svelte is better than React (it's state management)"><!--]--><title>River's Blog: Blog - Why I feel Svelte is better than React (it's state management)</title>
	</head>
	<body data-sveltekit-preload-data="hover" style="margin:0">
		<div style="display: contents"><!--[--><!--[--><!----><div class="contents svelte-cwdlz"><div class="w-full flex justify-center px-6 mt-8 mb-8"><div class="flex flex-col md:flex-row justify-between items-center w-full max-w-[700px] gap-4"><a class="header-link svelte-1mhyy1c" href="/"><div class="flex items-center"><img src="/_app/immutable/assets/meditating-enby.Ddx2L9rE.svg" alt="a meditating non-binary person" height="80" class="h-20"> <h1 class="ml-5 text-4xl font-['Reenie_Beanie']">River's blog</h1></div></a> <div class="font-['Sofia_Sans']"><div class="flex gap-3"><div class="page svelte-1mhyy1c"><a href="/about-me" class="svelte-1mhyy1c ">About me</a></div> <div class="text-gray-400">/</div> <div class="page svelte-1mhyy1c"><a href="/feed" class="svelte-1mhyy1c highlighted">Feed</a></div></div></div></div></div><!----> <!----><!--[!--><!----><div class="content w-full max-w-3xl font-inter flex flex-col items-center mx-auto my-7"><div class="stuff book-review flex flex-col"><a href="/blog/blog-5" class="relative flex p-1.5 mb-5 no-underline text-black group"><img src="/scroll.svg" alt="" width="15" class="mr-5 transition-all duration-700 group-hover:hue-rotate-[151deg]"> <span class="take-away font-medium text-[#375883]">Blog #5</span> : Why I feel Svelte is better than React (it's state management) <div class="absolute bottom-0 left-10 w-[calc(100%-40px)] h-0.5 bg-[#5bcde9]"></div></a></div> <img src="/_app/immutable/assets/icon.CapEkUyB.jpg" alt="" width="200" class="my-5"> <div class="prose prose-lg dark:prose-invert max-w-none"><!----><h2 id="whyifeelsvelteisbetterthanreactitsstatemanagement">Why I feel Svelte is better than React (it's state management)</h2>
<p>The developer experience of svelte is miles better than react, apart from pre-planned request layout structures and less cognitive work on that area</p>
<p>And that's it, React projects get into state-hell very easily, and then users are forced to use alternative options such as https://github.com/pmndrs/zustand or https://jotai.org/</p>
<p>This is due to the fact that react by default does not have any "Global state storage" by default, so unless you are relying on the above mentioned libary – you likely will have to create a huge amount of inheritance and prop-drilling - which quickly gets messy and becomes a maintenance nightmare</p>
<p>for example, lets say you have a simple react function with children</p>
<pre><code class="tsx language-tsx">function App() {
    return (
        &lt;div&gt;
            &lt;h1&gt;App&lt;/h1&gt;
            &lt;Child /&gt;
        &lt;/div&gt;
    )
}

function Child() {
    return (
        &lt;div&gt;
            &lt;h2&gt;Child&lt;/h2&gt;
        &lt;/div&gt;
    )
}
</code></pre>
<p>and the way you use it is</p>
<pre><code class="tsx language-tsx">function App() {
    const [count, setCount] = useState(0)
    return (
        &lt;div&gt;
            &lt;h1&gt;App&lt;/h1&gt;
            &lt;Child count={count} setCount={setCount} /&gt;
        &lt;/div&gt;
    )
}
</code></pre>
<p>now imagine doing this for a complex state driven project, it clearly doesn't work</p>
<pre><code class="tsx language-tsx">function App() {
    const [count, setCount] = useState(0)
    const [place, setPlace] = useState("alaska")
    const [name, setName] = useState("river")
    // 30 different states to load from

    // 30 different props to pass down
    &lt;UserRepresentation count={count} setCount={setCount}, place={place} setPlace={setPlace}, name={name} setName={setName} /&gt;
}
</code></pre>
<p>This is probably not a "realistic" example, but in a practical sense, it is a nightmare to manage</p>
<p>So people turn to other libraries like zustand</p>
<p>here you use something similar to</p>
<pre><code class="tsx language-tsx">import { create } from 'zustand'

const useBearStore = create((set) =&gt; ({
  bears: 0,
  increasePopulation: () =&gt; set((state) =&gt; ({ bears: state.bears + 1 })),
  removeAllBears: () =&gt; set({ bears: 0 }),
}))

function BearCounter() {
  const bears = useBearStore((state) =&gt; state.bears)
  return &lt;h1&gt;{bears} around here ...&lt;/h1&gt;
}

function Controls() {
  const increasePopulation = useBearStore((state) =&gt; state.increasePopulation)
  return &lt;button onClick={increasePopulation}&gt;one up&lt;/button&gt;
}
</code></pre>
<p>This is indeed better, since it makes the stores "global" instead of something chained down</p>
<p>Svelte manages this via svelte stores, which I feel are alot alot more intuitive, and because they come pre-packaged in svelte, it is one less additional library to use</p>
<pre><code class="svelte language-svelte">import {writable} from 'svelte/store'

let count = writable(0)

function increment() {
    count.update((value) =&gt; value + 1)
}
</code></pre>
<p>and when using them in html, you can use the $ prefix to access the store</p>
<pre><code class="svelte language-svelte">&lt;h1&gt;{$count}&lt;/h1&gt;
&lt;button on:click={increment}&gt;Increment&lt;/button&gt;
</code></pre>
<p>that's it, ta-da!</p>
<p>To be honest, I do like jot-ai atoms which come close to this, but I didn't enjoy having to learn jot-ai to use it, and I don't enjoy the "useAtom" syntax</p>
<p>Here's an example of jot-ai atoms for completeness's sake</p>
<pre><code class="tsx language-tsx">import { atom } from "jotai"

const countAtom = atom(0)

function increment() {
    countAtom.update((value) =&gt; value + 1)
}
</code></pre>
<p>to use this in a react component</p>
<pre><code class="tsx language-tsx">import { useAtom } from "jotai"

function App() {
    const [count, setCount] = useAtom(countAtom)
    return (
        &lt;div&gt;
            &lt;h1&gt;{count}&lt;/h1&gt;
            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
        &lt;/div&gt;
    )
}
</code></pre>
<p>`</p><!----></div></div><!----><!--]--><!----></div><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_ocxgfp = {
						base: new URL("../..", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					const data = [null,{"type":"data","data":{blogNum:"5",markdown:"---\nshortSummary: Why I feel Svelte is better than React (it's state management)\nauthor: River / Aditya Shankar\ndated: 2025-05-24\ntitle: Why I feel Svelte is better than React (it's state management)\nicon: icon.jpg\n---\n\n## Why I feel Svelte is better than React (it's state management)\n\nThe developer experience of svelte is miles better than react, apart from pre-planned request layout structures and less cognitive work on that area\n\nAnd that's it, React projects get into state-hell very easily, and then users are forced to use alternative options such as https://github.com/pmndrs/zustand or https://jotai.org/\n\nThis is due to the fact that react by default does not have any \"Global state storage\" by default, so unless you are relying on the above mentioned libary – you likely will have to create a huge amount of inheritance and prop-drilling - which quickly gets messy and becomes a maintenance nightmare\n\nfor example, lets say you have a simple react function with children\n\n```tsx\nfunction App() {\n    return (\n        \u003Cdiv>\n            \u003Ch1>App\u003C/h1>\n            \u003CChild />\n        \u003C/div>\n    )\n}\n\nfunction Child() {\n    return (\n        \u003Cdiv>\n            \u003Ch2>Child\u003C/h2>\n        \u003C/div>\n    )\n}\n```\n\nand the way you use it is\n\n```tsx\nfunction App() {\n    const [count, setCount] = useState(0)\n    return (\n        \u003Cdiv>\n            \u003Ch1>App\u003C/h1>\n            \u003CChild count={count} setCount={setCount} />\n        \u003C/div>\n    )\n}\n```\n\n\nnow imagine doing this for a complex state driven project, it clearly doesn't work\n\n```tsx\nfunction App() {\n    const [count, setCount] = useState(0)\n    const [place, setPlace] = useState(\"alaska\")\n    const [name, setName] = useState(\"river\")\n    // 30 different states to load from\n    \n    // 30 different props to pass down\n    \u003CUserRepresentation count={count} setCount={setCount}, place={place} setPlace={setPlace}, name={name} setName={setName} />\n}\n```\n\nThis is probably not a \"realistic\" example, but in a practical sense, it is a nightmare to manage\n\nSo people turn to other libraries like zustand\n\nhere you use something similar to\n\n\n\n```tsx\nimport { create } from 'zustand'\n\nconst useBearStore = create((set) => ({\n  bears: 0,\n  increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),\n  removeAllBears: () => set({ bears: 0 }),\n}))\n\nfunction BearCounter() {\n  const bears = useBearStore((state) => state.bears)\n  return \u003Ch1>{bears} around here ...\u003C/h1>\n}\n\nfunction Controls() {\n  const increasePopulation = useBearStore((state) => state.increasePopulation)\n  return \u003Cbutton onClick={increasePopulation}>one up\u003C/button>\n}\n``` \n\nThis is indeed better, since it makes the stores \"global\" instead of something chained down\n\n\nSvelte manages this via svelte stores, which I feel are alot alot more intuitive, and because they come pre-packaged in svelte, it is one less additional library to use\n\n```svelte\nimport {writable} from 'svelte/store'\n\nlet count = writable(0)\n\nfunction increment() {\n    count.update((value) => value + 1)\n}\n```\n\nand when using them in html, you can use the $ prefix to access the store\n\n```svelte\n\u003Ch1>{$count}\u003C/h1>\n\u003Cbutton on:click={increment}>Increment\u003C/button>\n```\n\nthat's it, ta-da!\n\nTo be honest, I do like jot-ai atoms which come close to this, but I didn't enjoy having to learn jot-ai to use it, and I don't enjoy the \"useAtom\" syntax\n\nHere's an example of jot-ai atoms for completeness's sake\n\n```tsx\nimport { atom } from \"jotai\"\n\nconst countAtom = atom(0)\n\nfunction increment() {\n    countAtom.update((value) => value + 1)\n}\n```\n\nto use this in a react component\n\n```tsx\nimport { useAtom } from \"jotai\"\n\nfunction App() {\n    const [count, setCount] = useAtom(countAtom)\n    return (\n        \u003Cdiv>\n            \u003Ch1>{count}\u003C/h1>\n            \u003Cbutton onClick={() => setCount(count + 1)}>Increment\u003C/button>\n        \u003C/div>\n    )\n}\n````\n\n\n",icon:"/_app/immutable/assets/icon.CapEkUyB.jpg",markdownHTML:"\u003Ch2 id=\"whyifeelsvelteisbetterthanreactitsstatemanagement\">Why I feel Svelte is better than React (it's state management)\u003C/h2>\n\u003Cp>The developer experience of svelte is miles better than react, apart from pre-planned request layout structures and less cognitive work on that area\u003C/p>\n\u003Cp>And that's it, React projects get into state-hell very easily, and then users are forced to use alternative options such as https://github.com/pmndrs/zustand or https://jotai.org/\u003C/p>\n\u003Cp>This is due to the fact that react by default does not have any \"Global state storage\" by default, so unless you are relying on the above mentioned libary – you likely will have to create a huge amount of inheritance and prop-drilling - which quickly gets messy and becomes a maintenance nightmare\u003C/p>\n\u003Cp>for example, lets say you have a simple react function with children\u003C/p>\n\u003Cpre>\u003Ccode class=\"tsx language-tsx\">function App() {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;App&lt;/h1&gt;\n            &lt;Child /&gt;\n        &lt;/div&gt;\n    )\n}\n\nfunction Child() {\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Child&lt;/h2&gt;\n        &lt;/div&gt;\n    )\n}\n\u003C/code>\u003C/pre>\n\u003Cp>and the way you use it is\u003C/p>\n\u003Cpre>\u003Ccode class=\"tsx language-tsx\">function App() {\n    const [count, setCount] = useState(0)\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;App&lt;/h1&gt;\n            &lt;Child count={count} setCount={setCount} /&gt;\n        &lt;/div&gt;\n    )\n}\n\u003C/code>\u003C/pre>\n\u003Cp>now imagine doing this for a complex state driven project, it clearly doesn't work\u003C/p>\n\u003Cpre>\u003Ccode class=\"tsx language-tsx\">function App() {\n    const [count, setCount] = useState(0)\n    const [place, setPlace] = useState(\"alaska\")\n    const [name, setName] = useState(\"river\")\n    // 30 different states to load from\n\n    // 30 different props to pass down\n    &lt;UserRepresentation count={count} setCount={setCount}, place={place} setPlace={setPlace}, name={name} setName={setName} /&gt;\n}\n\u003C/code>\u003C/pre>\n\u003Cp>This is probably not a \"realistic\" example, but in a practical sense, it is a nightmare to manage\u003C/p>\n\u003Cp>So people turn to other libraries like zustand\u003C/p>\n\u003Cp>here you use something similar to\u003C/p>\n\u003Cpre>\u003Ccode class=\"tsx language-tsx\">import { create } from 'zustand'\n\nconst useBearStore = create((set) =&gt; ({\n  bears: 0,\n  increasePopulation: () =&gt; set((state) =&gt; ({ bears: state.bears + 1 })),\n  removeAllBears: () =&gt; set({ bears: 0 }),\n}))\n\nfunction BearCounter() {\n  const bears = useBearStore((state) =&gt; state.bears)\n  return &lt;h1&gt;{bears} around here ...&lt;/h1&gt;\n}\n\nfunction Controls() {\n  const increasePopulation = useBearStore((state) =&gt; state.increasePopulation)\n  return &lt;button onClick={increasePopulation}&gt;one up&lt;/button&gt;\n}\n\u003C/code>\u003C/pre>\n\u003Cp>This is indeed better, since it makes the stores \"global\" instead of something chained down\u003C/p>\n\u003Cp>Svelte manages this via svelte stores, which I feel are alot alot more intuitive, and because they come pre-packaged in svelte, it is one less additional library to use\u003C/p>\n\u003Cpre>\u003Ccode class=\"svelte language-svelte\">import {writable} from 'svelte/store'\n\nlet count = writable(0)\n\nfunction increment() {\n    count.update((value) =&gt; value + 1)\n}\n\u003C/code>\u003C/pre>\n\u003Cp>and when using them in html, you can use the $ prefix to access the store\u003C/p>\n\u003Cpre>\u003Ccode class=\"svelte language-svelte\">&lt;h1&gt;{$count}&lt;/h1&gt;\n&lt;button on:click={increment}&gt;Increment&lt;/button&gt;\n\u003C/code>\u003C/pre>\n\u003Cp>that's it, ta-da!\u003C/p>\n\u003Cp>To be honest, I do like jot-ai atoms which come close to this, but I didn't enjoy having to learn jot-ai to use it, and I don't enjoy the \"useAtom\" syntax\u003C/p>\n\u003Cp>Here's an example of jot-ai atoms for completeness's sake\u003C/p>\n\u003Cpre>\u003Ccode class=\"tsx language-tsx\">import { atom } from \"jotai\"\n\nconst countAtom = atom(0)\n\nfunction increment() {\n    countAtom.update((value) =&gt; value + 1)\n}\n\u003C/code>\u003C/pre>\n\u003Cp>to use this in a react component\u003C/p>\n\u003Cpre>\u003Ccode class=\"tsx language-tsx\">import { useAtom } from \"jotai\"\n\nfunction App() {\n    const [count, setCount] = useAtom(countAtom)\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;{count}&lt;/h1&gt;\n            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    )\n}\n\u003C/code>\u003C/pre>\n\u003Cp>`\u003C/p>",metadata:{shortSummary:"Why I feel Svelte is better than React (it's state management)",author:"River / Aditya Shankar",dated:"2025-05-24",title:"Why I feel Svelte is better than React (it's state management)",icon:"icon.jpg"}},"uses":{"params":["num"]}}];

					Promise.all([
						import("../../_app/immutable/entry/start.ZZYciD6m.js"),
						import("../../_app/immutable/entry/app.CEGcWpwQ.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 5],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
